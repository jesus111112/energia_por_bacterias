<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador 3D con Programaci√≥n por Bloques y Editor JS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: white;
        }
        
        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: 60px 1fr 200px;
            height: 100vh;
            gap: 0;
        }
        
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .btn-primary {
            background: #10b981;
            color: white;
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .tools-panel {
            background: rgba(15, 23, 42, 0.95);
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            padding: 20px;
        }
        
        .panel-section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .tool-btn {
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .tool-btn:hover, .tool-btn.active {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .tool-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .tool-name {
            font-size: 11px;
        }
        
        .color-picker-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .color-option:hover, .color-option.active {
            border-color: white;
            transform: scale(1.1);
        }
        
        .shape-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .shape-btn {
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .shape-btn:hover, .shape-btn.active {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
        }
        
        .canvas-area {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
        }
        
        .canvas-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .canvas-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
        }
        
        .properties-panel {
            background: rgba(15, 23, 42, 0.95);
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            padding: 20px;
        }
        
        .property-item {
            margin-bottom: 15px;
        }
        
        .property-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 5px;
        }
        
        .property-input {
            width: 100%;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            color: white;
            font-size: 13px;
        }
        
        .programming-panel {
            grid-column: 1 / -1;
            background: rgba(15, 23, 42, 0.95);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
        }
        
        .blocks-palette {
            width: 250px;
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 15px;
            overflow-y: auto;
        }
        
        .block-category {
            margin-bottom: 15px;
        }
        
        .category-title {
            font-size: 12px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 8px;
        }
        
        .block-item {
            padding: 10px;
            background: rgba(102, 126, 234, 0.2);
            border-left: 3px solid #667eea;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: move;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .block-item:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateX(5px);
        }
        
        .block-item.event { border-color: #f59e0b; background: rgba(245, 158, 11, 0.2); }
        .block-item.control { border-color: #10b981; background: rgba(16, 185, 129, 0.2); }
        .block-item.motion { border-color: #3b82f6; background: rgba(59, 130, 246, 0.2); }
        .block-item.looks { border-color: #8b5cf6; background: rgba(139, 92, 246, 0.2); }
        
        .workspace {
            flex: 1;
            padding: 15px;
            overflow: auto;
            position: relative;
        }
        
        .dropped-block {
            padding: 12px;
            background: rgba(102, 126, 234, 0.3);
            border-left: 4px solid #667eea;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: move;
        }
        
        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .block-actions {
            display: flex;
            gap: 5px;
        }
        
        .block-edit {
            background: #3b82f6;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .block-delete {
            background: #ef4444;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .block-code-editor {
            display: none;
            margin-top: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            padding: 10px;
        }
        
        .block-code-editor.active {
            display: block;
        }
        
        .code-editor-textarea {
            width: 100%;
            min-height: 100px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            color: #10b981;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            resize: vertical;
            line-height: 1.6;
        }
        
        .code-editor-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .btn-small {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 11px;
        }
        
        .btn-save {
            background: #10b981;
            color: white;
        }
        
        .btn-cancel {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .dropped-block.event { border-color: #f59e0b; background: rgba(245, 158, 11, 0.3); }
        .dropped-block.control { border-color: #10b981; background: rgba(16, 185, 129, 0.3); }
        .dropped-block.motion { border-color: #3b82f6; background: rgba(59, 130, 246, 0.3); }
        .dropped-block.looks { border-color: #8b5cf6; background: rgba(139, 92, 246, 0.3); }
        
        .code-output {
            width: 300px;
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 15px;
            overflow-y: auto;
        }
        
        .code-title {
            font-size: 12px;
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: 10px;
        }
        
        .code-preview {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: #10b981;
            white-space: pre-wrap;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: #1e293b;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            pointer-events: all;
        }
        
        /* Modal de ejecuci√≥n - posicionado arriba de propiedades */
        #runModal {
            background: transparent;
            justify-content: flex-end;
            align-items: flex-start;
            padding: 80px 20px 20px 0;
        }
        
        #runModal .modal-content {
            max-width: 330px;
            animation: slideInFromRight 0.3s ease;
        }
        
        /* Modales de importar/guardar - centrados pero m√°s peque√±os */
        #importModal .modal-content,
        #saveModal .modal-content {
            max-width: 450px;
            animation: scaleIn 0.3s ease;
        }
        
        @keyframes slideInFromRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes scaleIn {
            from {
                transform: scale(0.9);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fbbf24;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        .modal-text {
            margin-bottom: 15px;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                üé® Simulador 3D + Programaci√≥n JS
            </div>
            <div class="header-actions">
                <button class="btn btn-secondary" onclick="clearAll()">üóëÔ∏è Limpiar</button>
                <button class="btn btn-secondary" onclick="importProject()">üìÇ Importar</button>
                <button class="btn btn-secondary" onclick="saveProject()">üíæ Guardar</button>
                <button class="btn btn-primary" onclick="runSimulation()">‚ñ∂Ô∏è Ejecutar</button>
            </div>
        </div>
        
        <div class="tools-panel">
            <div class="panel-section">
                <div class="section-title">üîß Herramientas</div>
                <div class="tool-grid">
                    <div class="tool-btn active" onclick="selectTool('select')" data-tool="select">
                        <div class="tool-icon">üëÜ</div>
                        <div class="tool-name">Seleccionar</div>
                    </div>
                    <div class="tool-btn" onclick="selectTool('move')" data-tool="move">
                        <div class="tool-icon">‚úã</div>
                        <div class="tool-name">Mover</div>
                    </div>
                    <div class="tool-btn" onclick="selectTool('rotate')" data-tool="rotate">
                        <div class="tool-icon">üîÑ</div>
                        <div class="tool-name">Rotar</div>
                    </div>
                    <div class="tool-btn" onclick="selectTool('scale')" data-tool="scale">
                        <div class="tool-icon">‚ÜîÔ∏è</div>
                        <div class="tool-name">Escalar</div>
                    </div>
                    <div class="tool-btn" onclick="selectTool('paint')" data-tool="paint">
                        <div class="tool-icon">üé®</div>
                        <div class="tool-name">Pintar</div>
                    </div>
                    <div class="tool-btn" onclick="selectTool('delete')" data-tool="delete">
                        <div class="tool-icon">üóëÔ∏è</div>
                        <div class="tool-name">Eliminar</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">üì¶ Formas 3D</div>
                <div class="shape-selector">
                    <div class="shape-btn" onclick="addShape('box')">
                        ‚óºÔ∏è Cubo
                    </div>
                    <div class="shape-btn" onclick="addShape('sphere')">
                        ‚ö™ Esfera
                    </div>
                    <div class="shape-btn" onclick="addShape('cylinder')">
                        üóúÔ∏è Cilindro
                    </div>
                    <div class="shape-btn" onclick="addShape('cone')">
                        üî∫ Cono
                    </div>
                    <div class="shape-btn" onclick="addShape('torus')">
                        üç© Toroide
                    </div>
                    <div class="shape-btn" onclick="addShape('plane')">
                        ‚ñ≠ Plano
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">üé® Colores</div>
                <div class="color-picker-container">
                    <div class="color-option active" style="background: #ef4444;" onclick="selectColor('#ef4444')"></div>
                    <div class="color-option" style="background: #f59e0b;" onclick="selectColor('#f59e0b')"></div>
                    <div class="color-option" style="background: #10b981;" onclick="selectColor('#10b981')"></div>
                    <div class="color-option" style="background: #3b82f6;" onclick="selectColor('#3b82f6')"></div>
                    <div class="color-option" style="background: #8b5cf6;" onclick="selectColor('#8b5cf6')"></div>
                    <div class="color-option" style="background: #ec4899;" onclick="selectColor('#ec4899')"></div>
                    <div class="color-option" style="background: #fbbf24;" onclick="selectColor('#fbbf24')"></div>
                    <div class="color-option" style="background: #14b8a6;" onclick="selectColor('#14b8a6')"></div>
                    <div class="color-option" style="background: #6366f1;" onclick="selectColor('#6366f1')"></div>
                    <div class="color-option" style="background: #ffffff;" onclick="selectColor('#ffffff')"></div>
                </div>
            </div>
        </div>
        
        <div class="canvas-area">
            <div id="canvas3d"></div>
            <div class="canvas-controls">
                <button class="btn btn-secondary" onclick="resetCamera()">üì∑ Reset C√°mara</button>
                <button class="btn btn-secondary" onclick="toggleGrid()">‚äû Grid</button>
            </div>
            <div class="canvas-info">
                <div>üñ±Ô∏è Click: Seleccionar | Arrastrar: Rotar vista</div>
                <div id="object-count">Objetos: 0</div>
            </div>
        </div>
        
        <div class="properties-panel">
            <div class="section-title">‚öôÔ∏è Propiedades</div>
            <div id="properties-content">
                <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">
                    Selecciona un objeto para ver sus propiedades
                </p>
            </div>
        </div>
        
        <div class="programming-panel">
            <div class="blocks-palette">
                <div class="block-category">
                    <div class="category-title">üéØ Eventos</div>
                    <div class="block-item event" draggable="true" data-block="start">
                        Al iniciar programa
                    </div>
                    <div class="block-item event" draggable="true" data-block="click">
                        Al hacer clic en objeto
                    </div>
                    <div class="block-item event" draggable="true" data-block="key">
                        Al presionar tecla [espacio]
                    </div>
                </div>
                
                <div class="block-category">
                    <div class="category-title">üéÆ Control</div>
                    <div class="block-item control" draggable="true" data-block="wait">
                        Esperar [1] segundos
                    </div>
                    <div class="block-item control" draggable="true" data-block="repeat">
                        Repetir [10] veces
                    </div>
                    <div class="block-item control" draggable="true" data-block="forever">
                        Por siempre
                    </div>
                    <div class="block-item control" draggable="true" data-block="if">
                        Si [condici√≥n] entonces
                    </div>
                </div>
                
                <div class="block-category">
                    <div class="category-title">üöÄ Movimiento</div>
                    <div class="block-item motion" draggable="true" data-block="moveX">
                        Mover X por [10]
                    </div>
                    <div class="block-item motion" draggable="true" data-block="moveY">
                        Mover Y por [10]
                    </div>
                    <div class="block-item motion" draggable="true" data-block="moveZ">
                        Mover Z por [10]
                    </div>
                    <div class="block-item motion" draggable="true" data-block="rotate">
                        Rotar [90] grados
                    </div>
                    <div class="block-item motion" draggable="true" data-block="goto">
                        Ir a X:[0] Y:[0] Z:[0]
                    </div>
                </div>
                
                <div class="block-category">
                    <div class="category-title">üëÅÔ∏è Apariencia</div>
                    <div class="block-item looks" draggable="true" data-block="color">
                        Cambiar color a [rojo]
                    </div>
                    <div class="block-item looks" draggable="true" data-block="size">
                        Cambiar tama√±o a [100]%
                    </div>
                    <div class="block-item looks" draggable="true" data-block="show">
                        Mostrar
                    </div>
                    <div class="block-item looks" draggable="true" data-block="hide">
                        Ocultar
                    </div>
                </div>
                
                <div class="block-category">
                    <div class="category-title">üí• F√≠sica y Efectos</div>
                    <div class="block-item looks" draggable="true" data-block="fragment">
                        Fragmentar en [20] piezas
                    </div>
                    <div class="block-item looks" draggable="true" data-block="fall">
                        Hacer caer objeto
                    </div>
                    <div class="block-item looks" draggable="true" data-block="fallshatter">
                        Caer y fragmentar [25] piezas
                    </div>
                    <div class="block-item looks" draggable="true" data-block="explode">
                        Explotar objeto
                    </div>
                    <div class="block-item looks" draggable="true" data-block="oscillateBlock">
                        Oscilar en eje [y] amplitud [1]
                    </div>
                    <div class="block-item looks" draggable="true" data-block="pulseBlock">
                        Pulsar velocidad [2]
                    </div>
                </div>
            </div>
            
            <div class="workspace" id="workspace">
                <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px;">
                    Arrastra bloques aqu√≠ para programar<br>
                    <span style="font-size: 11px;">üí° Usa el bot√≥n "Editar" para c√≥digo JavaScript personalizado</span>
                </p>
            </div>
            
            <div class="code-output">
                <div class="code-title">üíª C√≥digo JavaScript</div>
                <div class="code-preview" id="code-preview">// El c√≥digo aparecer√° aqu√≠...</div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="runModal" onclick="if(event.target === this) closeModal()">
        <div class="modal-content">
            <div class="modal-title">
                ‚ñ∂Ô∏è Ejecutando Simulaci√≥n
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <div class="modal-text" id="runStatus">
                Iniciando simulaci√≥n...
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="stopSimulation()">‚èπÔ∏è Detener</button>
            </div>
        </div>
    </div>

    <div class="modal" id="importModal" onclick="if(event.target === this) closeImportModal()">
        <div class="modal-content">
            <div class="modal-title">
                üìÇ Importar Proyecto
                <button class="modal-close" onclick="closeImportModal()">√ó</button>
            </div>
            <div class="modal-text">
                <p style="margin-bottom: 15px;">Selecciona un archivo de proyecto (.json):</p>
                <p style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 15px;">
                    ‚úÖ Compatible con proyectos MFC y proyectos 3D est√°ndar
                </p>
                <input type="file" id="fileInput" accept=".json" style="
                    width: 100%;
                    padding: 10px;
                    background: rgba(255,255,255,0.1);
                    border: 2px dashed rgba(255,255,255,0.3);
                    border-radius: 8px;
                    color: white;
                    cursor: pointer;
                    margin-bottom: 15px;
                ">
                <div id="importStatus" style="color: #10b981; font-size: 13px;"></div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeImportModal()">Cancelar</button>
                <button class="btn btn-primary" onclick="loadSelectedFile()">Cargar Proyecto</button>
            </div>
        </div>
    </div>

    <div class="modal" id="saveModal" onclick="if(event.target === this) closeSaveModal()">
        <div class="modal-content">
            <div class="modal-title">
                üíæ Guardar Proyecto
                <button class="modal-close" onclick="closeSaveModal()">√ó</button>
            </div>
            <div class="modal-text">
                <p style="margin-bottom: 15px;">Dale un nombre a tu proyecto:</p>
                <input type="text" id="projectName" class="property-input" placeholder="Mi_Proyecto_3D" value="Mi_Proyecto_3D" style="margin-bottom: 15px;">
                <div style="background: rgba(16, 185, 129, 0.2); padding: 12px; border-radius: 8px; font-size: 13px; line-height: 1.6;">
                    <strong>üì¶ Tu proyecto incluye:</strong><br>
                    ‚Ä¢ <span id="saveObjectCount">0</span> objetos 3D<br>
                    ‚Ä¢ <span id="saveBlockCount">0</span> bloques de programaci√≥n<br>
                    ‚Ä¢ C√≥digo JavaScript personalizado<br>
                    <br>
                    El archivo se descargar√° a tu carpeta de Descargas
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeSaveModal()">Cancelar</button>
                <button class="btn btn-primary" onclick="confirmSaveProject()">üíæ Descargar Archivo</button>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let objects = [];
        let selectedObject = null;
        let currentTool = 'select';
        let currentColor = '#ef4444';
        let isMouseDown = false;
        let gridHelper;
        
        let programBlocks = [];
        let blockCounter = 0;
        let isSimulationRunning = false;
        
        function initThree() {
            const container = document.getElementById('canvas3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x16213e);
            
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Sistema de animaci√≥n continua basado en estados
            objects.forEach(obj => {
                // Auto-rotaci√≥n b√°sica
                if (obj.userData.animate) {
                    obj.rotation.y += 0.02;
                }
                
                // Sistema de rotaci√≥n configurable
                if (obj.userData.autoRotate) {
                    obj.rotation.y += obj.userData.rotateSpeed || 0.01;
                    
                    // Contador de vueltas
                    if (obj.rotation.y >= Math.PI * 2) {
                        obj.rotation.y = 0;
                        obj.userData.turns = (obj.userData.turns || 0) + 1;
                    }
                }
                
                // Movimiento continuo en X, Y, Z
                if (obj.userData.moveX) {
                    obj.position.x += obj.userData.moveSpeedX || 0.01;
                }
                if (obj.userData.moveY) {
                    obj.position.y += obj.userData.moveSpeedY || 0.01;
                }
                if (obj.userData.moveZ) {
                    obj.position.z += obj.userData.moveSpeedZ || 0.01;
                }
                
                // Sistema de f√≠sica para ca√≠da y fragmentaci√≥n
                if (obj.userData.falling) {
                    // Aplicar gravedad
                    obj.userData.velocityY = (obj.userData.velocityY || 0) - 0.008;
                    obj.position.y += obj.userData.velocityY;
                    
                    // Rotaci√≥n durante ca√≠da
                    obj.rotation.x += obj.userData.fallRotationX || 0.02;
                    obj.rotation.z += obj.userData.fallRotationZ || 0.01;
                    
                    // Detectar colisi√≥n con el suelo
                    const floorLevel = gridHelper.visible ? 0 : -5;
                    
                    if (obj.position.y < floorLevel) {
                        if (gridHelper.visible) {
                            // Rebotar en el suelo
                            obj.position.y = floorLevel;
                            obj.userData.velocityY *= -0.4; // Rebote con p√©rdida de energ√≠a
                            
                            // Detener si la velocidad es muy baja
                            if (Math.abs(obj.userData.velocityY) < 0.02) {
                                obj.userData.falling = false;
                                obj.userData.velocityY = 0;
                                obj.userData.fallRotationX = 0;
                                obj.userData.fallRotationZ = 0;
                                console.log('üí• Objeto impact√≥ el suelo y se detuvo');
                            }
                        } else {
                            // Sin suelo, desaparecer al caer muy bajo
                            obj.userData.falling = false;
                            obj.visible = false;
                            console.log('üí• Objeto cay√≥ al vac√≠o');
                        }
                    }
                }
                
                // Sistema de fragmentaci√≥n
                if (obj.userData.fragments && obj.userData.fragments.length > 0) {
                    obj.userData.fragments.forEach(fragment => {
                        if (fragment.userData.active) {
                            // Aplicar f√≠sica a cada fragmento
                            fragment.userData.velocity = fragment.userData.velocity || {
                                x: (Math.random() - 0.5) * 0.15,
                                y: Math.random() * 0.1,
                                z: (Math.random() - 0.5) * 0.15
                            };
                            
                            // Gravedad
                            fragment.userData.velocity.y -= 0.01;
                            
                            // Aplicar velocidad
                            fragment.position.x += fragment.userData.velocity.x;
                            fragment.position.y += fragment.userData.velocity.y;
                            fragment.position.z += fragment.userData.velocity.z;
                            
                            // Rotaci√≥n aleatoria
                            fragment.rotation.x += fragment.userData.rotVel.x;
                            fragment.rotation.y += fragment.userData.rotVel.y;
                            fragment.rotation.z += fragment.userData.rotVel.z;
                            
                            // Colisi√≥n con el suelo
                            const floorLevel = gridHelper.visible ? 0.15 : -10;
                            
                            if (fragment.position.y < floorLevel) {
                                if (gridHelper.visible) {
                                    // Rebotar en el suelo
                                    fragment.position.y = floorLevel;
                                    fragment.userData.velocity.y *= -0.5; // Rebote
                                    fragment.userData.velocity.x *= 0.95; // Fricci√≥n
                                    fragment.userData.velocity.z *= 0.95; // Fricci√≥n
                                    
                                    // Reducir rotaci√≥n con fricci√≥n
                                    fragment.userData.rotVel.x *= 0.98;
                                    fragment.userData.rotVel.y *= 0.98;
                                    fragment.userData.rotVel.z *= 0.98;
                                    
                                    // Detener si casi no se mueve
                                    if (Math.abs(fragment.userData.velocity.y) < 0.01 && 
                                        Math.abs(fragment.userData.velocity.x) < 0.005 &&
                                        Math.abs(fragment.userData.velocity.z) < 0.005) {
                                        fragment.userData.velocity = { x: 0, y: 0, z: 0 };
                                        fragment.userData.rotVel = { x: 0, y: 0, z: 0 };
                                        // No desactivar, dejar en el suelo
                                    }
                                } else {
                                    // Sin suelo, desaparecer al caer muy bajo
                                    fragment.userData.active = false;
                                    fragment.visible = false;
                                }
                            }
                        }
                    });
                }
                
                // Sistema de explosi√≥n
                if (obj.userData.exploding) {
                    obj.userData.explodeTime = (obj.userData.explodeTime || 0) + 1;
                    
                    // Expandir durante 60 frames (1 segundo)
                    if (obj.userData.explodeTime < 60) {
                        const scale = 1 + (obj.userData.explodeTime / 60) * 2;
                        obj.scale.set(scale, scale, scale);
                        
                        // Hacer transparente
                        if (obj.material) {
                            obj.material.transparent = true;
                            obj.material.opacity = 1 - (obj.userData.explodeTime / 60);
                        }
                    } else {
                        obj.visible = false;
                        obj.userData.exploding = false;
                    }
                }
                
                // Sistema de temporizador por frames
                if (obj.userData.timerEnabled) {
                    obj.userData.timerFrames = (obj.userData.timerFrames || 0) + 1;
                    
                    // Ejecutar acci√≥n cada X frames (60 frames ‚âà 1 segundo a 60fps)
                    if (obj.userData.timerAction && obj.userData.timerFrames >= (obj.userData.timerInterval || 60)) {
                        obj.userData.timerFrames = 0;
                        // Trigger para acciones peri√≥dicas
                        if (obj.userData.timerCallback) {
                            obj.userData.timerCallback(obj);
                        }
                    }
                }
                
                // Animaci√≥n de bacterias (para celdas MFC)
                if (obj.userData.animateBacteria && obj.type === 'Group') {
                    obj.traverse(child => {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            // Inicializar velocidad si no existe
                            if (!child.userData.velocity) {
                                child.userData.velocity = {
                                    x: (Math.random() - 0.5) * 0.03,
                                    y: (Math.random() - 0.5) * 0.03,
                                    z: (Math.random() - 0.5) * 0.03
                                };
                            }
                            
                            // Mover bacteria
                            child.position.x += child.userData.velocity.x;
                            child.position.y += child.userData.velocity.y;
                            child.position.z += child.userData.velocity.z;
                            
                            // Rebotar en l√≠mites
                            if (Math.abs(child.position.x) > 1.2) {
                                child.userData.velocity.x *= -1;
                            }
                            if (Math.abs(child.position.y) > 1.8) {
                                child.userData.velocity.y *= -1;
                            }
                            if (Math.abs(child.position.z) > 1.2) {
                                child.userData.velocity.z *= -1;
                            }
                            
                            // Brillo aleatorio
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = 0.3 + Math.sin(Date.now() * 0.005) * 0.3;
                            }
                        }
                    });
                }
                
                // Sistema de oscilaci√≥n (onda senoidal)
                if (obj.userData.oscillate) {
                    const time = Date.now() * 0.001;
                    const amplitude = obj.userData.oscillateAmplitude || 1;
                    const frequency = obj.userData.oscillateFrequency || 1;
                    
                    if (obj.userData.oscillateAxis === 'x') {
                        obj.position.x = obj.userData.oscillateCenter + Math.sin(time * frequency) * amplitude;
                    } else if (obj.userData.oscillateAxis === 'y') {
                        obj.position.y = obj.userData.oscillateCenter + Math.sin(time * frequency) * amplitude;
                    } else if (obj.userData.oscillateAxis === 'z') {
                        obj.position.z = obj.userData.oscillateCenter + Math.sin(time * frequency) * amplitude;
                    }
                }
                
                // Sistema de escala pulsante
                if (obj.userData.pulse) {
                    const time = Date.now() * 0.001;
                    const pulseSpeed = obj.userData.pulseSpeed || 2;
                    const pulseAmount = obj.userData.pulseAmount || 0.2;
                    const baseScale = obj.userData.baseScale || 1;
                    
                    const scale = baseScale + Math.sin(time * pulseSpeed) * pulseAmount;
                    obj.scale.set(scale, scale, scale);
                }
                
                // Sistema de cambio de color c√≠clico
                if (obj.userData.colorCycle && obj.material) {
                    const time = Date.now() * 0.001;
                    const speed = obj.userData.colorCycleSpeed || 1;
                    
                    const r = Math.sin(time * speed) * 0.5 + 0.5;
                    const g = Math.sin(time * speed + 2) * 0.5 + 0.5;
                    const b = Math.sin(time * speed + 4) * 0.5 + 0.5;
                    
                    obj.material.color.setRGB(r, g, b);
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Funci√≥n para fragmentar objetos
        function fragmentObject(object, pieces = 12) {
            console.log(`üí• Fragmentando objeto en ${pieces} piezas...`);
            
            // Ocultar objeto original
            object.visible = false;
            
            // Crear fragmentos
            const fragments = [];
            const basePosition = object.position.clone();
            
            for (let i = 0; i < pieces; i++) {
                // Crear geometr√≠a del fragmento (cubo peque√±o)
                const size = 0.3 + Math.random() * 0.3;
                const fragmentGeometry = new THREE.BoxGeometry(size, size, size);
                
                // Material del fragmento (mismo color que el original o aleatorio)
                let fragmentColor = 0xff4444;
                if (object.material && object.material.color) {
                    fragmentColor = object.material.color.getHex();
                } else if (object.type === 'Group') {
                    // Para grupos MFC, usar color amarillo (√°nodo)
                    fragmentColor = 0xfbbf24;
                }
                
                const fragmentMaterial = new THREE.MeshPhongMaterial({
                    color: fragmentColor,
                    flatShading: true
                });
                
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
                
                // Posicionar fragmento cerca del objeto original
                fragment.position.set(
                    basePosition.x + (Math.random() - 0.5) * 2,
                    basePosition.y + (Math.random() - 0.5) * 2,
                    basePosition.z + (Math.random() - 0.5) * 2
                );
                
                // Velocidad inicial aleatoria
                fragment.userData.velocity = {
                    x: (Math.random() - 0.5) * 0.2,
                    y: Math.random() * 0.15,
                    z: (Math.random() - 0.5) * 0.2
                };
                
                // Velocidad de rotaci√≥n aleatoria
                fragment.userData.rotVel = {
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1,
                    z: (Math.random() - 0.5) * 0.1
                };
                
                fragment.userData.active = true;
                fragment.castShadow = true;
                
                scene.add(fragment);
                fragments.push(fragment);
            }
            
            // Guardar fragmentos en el objeto
            object.userData.fragments = fragments;
            
            console.log(`‚úÖ ${pieces} fragmentos creados y cayendo`);
            
            return fragments;
        }
        
        // Funci√≥n para hacer caer un objeto
        function makeObjectFall(object) {
            console.log('üåä Objeto comenzando a caer...');
            object.userData.falling = true;
            object.userData.velocityY = 0;
            object.userData.fallRotationX = (Math.random() - 0.5) * 0.05;
            object.userData.fallRotationZ = (Math.random() - 0.5) * 0.05;
        }
        
        // Funci√≥n para explotar un objeto
        function explodeObject(object) {
            console.log('üí• Objeto explotando...');
            object.userData.exploding = true;
            object.userData.explodeTime = 0;
        }
        
        // Funci√≥n combinada: caer y fragmentar
        function fallAndShatter(object, pieces = 12) {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üí• SECUENCIA: CAER Y FRAGMENTAR');
            console.log(`üéØ Objeto: ${object.userData.name || 'desconocido'}`);
            console.log(`‚äû Grid activo: ${gridHelper.visible ? 'S√ç (hay suelo)' : 'NO (ca√≠da al vac√≠o)'}`);
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // Paso 1: Fragmentar inmediatamente
            fragmentObject(object, pieces);
            
            console.log('‚úÖ Secuencia iniciada');
        }
        
        // Funci√≥n para limpiar fragmentos del suelo
        function clearFragments() {
            let count = 0;
            objects.forEach(obj => {
                if (obj.userData.fragments) {
                    obj.userData.fragments.forEach(fragment => {
                        scene.remove(fragment);
                        count++;
                    });
                    obj.userData.fragments = [];
                }
            });
            console.log(`üßπ ${count} fragmentos eliminados del suelo`);
        }
        
        // Funci√≥n para resetear objeto fragmentado
        function resetObject(object) {
            if (object.userData.fragments) {
                object.userData.fragments.forEach(fragment => {
                    scene.remove(fragment);
                });
                object.userData.fragments = [];
            }
            object.visible = true;
            object.userData.falling = false;
            object.userData.exploding = false;
            object.userData.velocityY = 0;
            console.log(`‚ôªÔ∏è Objeto "${object.userData.name}" reseteado`);
        }
        
        // Funci√≥n para activar/desactivar el suelo visualmente
        function toggleFloor() {
            const wasVisible = gridHelper.visible;
            gridHelper.visible = !gridHelper.visible;
            
            if (gridHelper.visible) {
                console.log('‚äû GRID ACTIVADO - Los fragmentos rebotar√°n en el suelo (y=0)');
            } else {
                console.log('‚äû GRID DESACTIVADO - Los fragmentos caer√°n al vac√≠o');
            }
        }
        
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        }
        
        function selectColor(color) {
            currentColor = color;
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function addShape(type) {
            let geometry;
            
            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(0.5, 1, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(2, 2);
                    break;
            }
            
            const material = new THREE.MeshPhongMaterial({ 
                color: currentColor,
                flatShading: false
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(
                Math.random() * 4 - 2,
                1,
                Math.random() * 4 - 2
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = {
                id: Date.now(),
                type: type,
                name: `${type}_${objects.length + 1}`,
                animate: false
            };
            
            scene.add(mesh);
            objects.push(mesh);
            updateObjectCount();
        }
        
        function onCanvasClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Intersectar con todos los objetos de la escena (incluye grupos)
            const allObjects = [];
            scene.traverse(child => {
                if (child.isMesh || child.type === 'Group') {
                    allObjects.push(child);
                }
            });
            
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                let object = intersects[0].object;
                
                // Si es parte de un grupo, subir al grupo padre principal
                while (object.parent && object.parent !== scene) {
                    // Si el padre est√° en objects, usar ese
                    if (objects.includes(object.parent)) {
                        object = object.parent;
                        break;
                    }
                    object = object.parent;
                }
                
                // Si el objeto clickeado no est√° en objects pero su padre s√≠, usar el padre
                if (!objects.includes(object) && object.parent && objects.includes(object.parent)) {
                    object = object.parent;
                }
                
                switch(currentTool) {
                    case 'select':
                        selectObject(object);
                        break;
                    case 'paint':
                        if (object.material) {
                            object.material.color.setStyle(currentColor);
                        }
                        break;
                    case 'delete':
                        deleteObject(object);
                        break;
                }
            } else {
                if (currentTool === 'select') {
                    deselectObject();
                }
            }
        }
        
        function selectObject(object) {
            if (selectedObject) {
                if (selectedObject.traverse) {
                    selectedObject.traverse(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                } else if (selectedObject.material) {
                    selectedObject.material.emissive.setHex(0x000000);
                }
            }
            
            selectedObject = object;
            
            if (selectedObject.traverse) {
                selectedObject.traverse(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissive.setHex(0x555555);
                    }
                });
            } else if (selectedObject.material) {
                selectedObject.material.emissive.setHex(0x555555);
            }
            
            updatePropertiesPanel();
        }
        
        function deselectObject() {
            if (selectedObject) {
                if (selectedObject.traverse) {
                    selectedObject.traverse(child => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    });
                } else if (selectedObject.material) {
                    selectedObject.material.emissive.setHex(0x000000);
                }
                selectedObject = null;
                clearPropertiesPanel();
            }
        }
        
        function deleteObject(object) {
            scene.remove(object);
            objects = objects.filter(obj => obj !== object);
            if (selectedObject === object) {
                deselectObject();
            }
            updateObjectCount();
        }
        
        function updatePropertiesPanel() {
            if (!selectedObject) return;
            
            const props = document.getElementById('properties-content');
            const objType = selectedObject.userData.type || 'desconocido';
            const objName = selectedObject.userData.name || 'Sin nombre';
            
            props.innerHTML = `
                <div class="property-item">
                    <div class="property-label">Nombre</div>
                    <input type="text" class="property-input" value="${objName}" 
                           onchange="selectedObject.userData.name = this.value">
                </div>
                <div class="property-item">
                    <div class="property-label">Tipo</div>
                    <input type="text" class="property-input" value="${objType}" disabled>
                </div>
                <div class="property-item">
                    <div class="property-label">ID</div>
                    <input type="text" class="property-input" value="${selectedObject.userData.id || 'N/A'}" disabled>
                </div>
                <div class="property-item">
                    <div class="property-label">Posici√≥n X</div>
                    <input type="number" class="property-input" step="0.1" value="${selectedObject.position.x.toFixed(2)}" 
                           onchange="selectedObject.position.x = parseFloat(this.value)">
                </div>
                <div class="property-item">
                    <div class="property-label">Posici√≥n Y</div>
                    <input type="number" class="property-input" step="0.1" value="${selectedObject.position.y.toFixed(2)}" 
                           onchange="selectedObject.position.y = parseFloat(this.value)">
                </div>
                <div class="property-item">
                    <div class="property-label">Posici√≥n Z</div>
                    <input type="number" class="property-input" step="0.1" value="${selectedObject.position.z.toFixed(2)}" 
                           onchange="selectedObject.position.z = parseFloat(this.value)">
                </div>
                <div class="property-item">
                    <div class="property-label">Escala</div>
                    <input type="number" class="property-input" step="0.1" value="${selectedObject.scale.x.toFixed(2)}" 
                           onchange="selectedObject.scale.set(parseFloat(this.value), parseFloat(this.value), parseFloat(this.value))">
                </div>
                <div class="property-item">
                    <div class="property-label">Rotaci√≥n Y (grados)</div>
                    <input type="number" class="property-input" step="5" value="${Math.round(selectedObject.rotation.y * 180 / Math.PI)}" 
                           onchange="selectedObject.rotation.y = parseFloat(this.value) * Math.PI / 180">
                </div>
                ${selectedObject.material && selectedObject.material.color ? `
                <div class="property-item">
                    <div class="property-label">Color</div>
                    <input type="color" class="property-input" value="${'#' + selectedObject.material.color.getHexString()}" 
                           onchange="selectedObject.material.color.setStyle(this.value)">
                </div>
                ` : ''}
                <div class="property-item">
                    <div class="property-label" style="color: #10b981; margin-top: 15px;">
                        ${objects.includes(selectedObject) ? '‚úÖ Objeto programable' : '‚ö†Ô∏è No est√° en lista de objetos'}
                    </div>
                </div>
            `;
        }
        
        function clearPropertiesPanel() {
            document.getElementById('properties-content').innerHTML = `
                <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">
                    Selecciona un objeto para ver sus propiedades
                </p>
            `;
        }
        
        let previousMousePosition = { x: 0, y: 0 };
        
        function onMouseDown(event) {
            isMouseDown = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            if (selectedObject && currentTool === 'move') {
                selectedObject.position.x += deltaX * 0.01;
                selectedObject.position.y -= deltaY * 0.01;
                updatePropertiesPanel();
            } else if (selectedObject && currentTool === 'rotate') {
                selectedObject.rotation.y += deltaX * 0.01;
                selectedObject.rotation.x += deltaY * 0.01;
                updatePropertiesPanel();
            } else if (selectedObject && currentTool === 'scale') {
                const scale = selectedObject.scale.x + deltaY * 0.01;
                selectedObject.scale.set(scale, scale, scale);
                updatePropertiesPanel();
            } else {
                camera.position.x = camera.position.x * Math.cos(deltaX * 0.01) - camera.position.z * Math.sin(deltaX * 0.01);
                camera.position.z = camera.position.x * Math.sin(deltaX * 0.01) + camera.position.z * Math.cos(deltaX * 0.01);
                camera.lookAt(0, 0, 0);
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas3d');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function resetCamera() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleGrid() {
            gridHelper.visible = !gridHelper.visible;
            
            if (gridHelper.visible) {
                console.log('‚äû GRID ACTIVADO - Ahora hay suelo en y=0');
                console.log('üí° Los fragmentos rebotar√°n y se quedar√°n en el suelo');
            } else {
                console.log('‚äû GRID DESACTIVADO - Sin suelo');
                console.log('üí° Los fragmentos caer√°n al vac√≠o y desaparecer√°n');
            }
        }
        
        function updateObjectCount() {
            document.getElementById('object-count').textContent = `Objetos: ${objects.length}`;
        }
        
        function clearAll() {
            if (confirm('¬øEst√°s seguro de eliminar todos los objetos y bloques?')) {
                objects.forEach(obj => scene.remove(obj));
                objects = [];
                programBlocks = [];
                deselectObject();
                updateObjectCount();
                updateWorkspace();
                updateCodePreview();
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initThree();
            setupDragAndDrop();
        });
        
        function setupDragAndDrop() {
            const workspace = document.getElementById('workspace');
            
            document.querySelectorAll('.block-item').forEach(block => {
                block.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('blockType', block.dataset.block);
                    e.dataTransfer.setData('blockText', block.textContent.trim());
                    e.dataTransfer.setData('blockCategory', block.classList.contains('event') ? 'event' : 
                                                            block.classList.contains('control') ? 'control' :
                                                            block.classList.contains('motion') ? 'motion' : 'looks');
                });
            });
            
            workspace.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });
            
            workspace.addEventListener('drop', (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                const blockText = e.dataTransfer.getData('blockText');
                const blockCategory = e.dataTransfer.getData('blockCategory');
                
                addBlockToWorkspace(blockType, blockText, blockCategory);
            });
        }
        
        function addBlockToWorkspace(type, text, category) {
            const block = {
                id: blockCounter++,
                type: type,
                text: text,
                category: category,
                params: extractParams(text),
                customCode: ''
            };
            
            programBlocks.push(block);
            updateWorkspace();
            updateCodePreview();
        }
        
        function extractParams(text) {
            const params = [];
            const matches = text.match(/\[([^\]]+)\]/g);
            if (matches) {
                matches.forEach(match => {
                    params.push(match.replace(/[\[\]]/g, ''));
                });
            }
            return params;
        }
        
        function updateWorkspace() {
            const workspace = document.getElementById('workspace');
            
            if (programBlocks.length === 0) {
                workspace.innerHTML = `
                    <p style="color: rgba(255,255,255,0.5); text-align: center; padding: 40px;">
                        Arrastra bloques aqu√≠ para programar<br>
                        <span style="font-size: 11px;">üí° Usa el bot√≥n "Editar" para c√≥digo JavaScript personalizado</span>
                    </p>
                `;
                return;
            }
            
            workspace.innerHTML = '';
            
            programBlocks.forEach((block, index) => {
                const blockEl = document.createElement('div');
                blockEl.className = `dropped-block ${block.category}`;
                blockEl.innerHTML = `
                    <div class="block-header">
                        <span>${block.text}</span>
                        <div class="block-actions">
                            <button class="block-edit" onclick="toggleCodeEditor(${index})">
                                ${block.customCode ? 'üìù Editado' : '‚úèÔ∏è Editar'}
                            </button>
                            <button class="block-delete" onclick="removeBlock(${index})">‚úï</button>
                        </div>
                    </div>
                    <div class="block-code-editor" id="editor-${index}">
                        <div style="color: #fbbf24; font-size: 11px; margin-bottom: 8px; font-weight: 600;">
                            üíª Editor de Configuraci√≥n JavaScript
                        </div>
                        <div style="background: rgba(16, 185, 129, 0.2); padding: 8px; border-radius: 4px; font-size: 10px; margin-bottom: 8px; line-height: 1.4;">
                            <strong>‚úÖ Configura estados</strong> (se ejecutan en animate())<br>
                            ‚ùå NO uses <code>await</code>, <code>sleep()</code> o bucles infinitos
                        </div>
                        <textarea class="code-editor-textarea" id="code-${index}" placeholder="// üéØ CONFIGURAR ANIMACIONES CONTINUAS:
//
// üîÑ Rotaci√≥n autom√°tica:
object.userData.autoRotate = true;
object.userData.rotateSpeed = 0.05;

// ü¶† Animar bacterias (para MFC):
object.userData.animateBacteria = true;

// üìç Movimiento continuo:
object.userData.moveX = true;
object.userData.moveSpeedX = 0.02;

// üåä Oscilar arriba/abajo:
object.userData.oscillate = true;
object.userData.oscillateAxis = 'y';
object.userData.oscillateAmplitude = 1;
object.userData.oscillateCenter = object.position.y;

// üíì Pulsar (cambiar tama√±o):
object.userData.pulse = true;
object.userData.pulseSpeed = 2;
object.userData.baseScale = 1;

// üåà Ciclo de colores:
object.userData.colorCycle = true;

// Variables: object, objects, scene, camera
console.log('Objeto configurado:', object.userData.name);">${block.customCode || getDefaultCode(block.type, block.params)}</textarea>
                        <div class="code-editor-actions">
                            <button class="btn-small btn-save" onclick="saveBlockCode(${index})">üíæ Guardar</button>
                            <button class="btn-small btn-cancel" onclick="cancelEditCode(${index})">‚ùå Cancelar</button>
                        </div>
                    </div>
                `;
                workspace.appendChild(blockEl);
            });
        }
        
        function getDefaultCode(type, params) {
            switch(type) {
                case 'moveX':
                    return `// Configurar movimiento continuo en X
object.userData.moveX = true;
object.userData.moveSpeedX = ${parseFloat(params[0]) / 100};
console.log('‚úÖ Movimiento X activado');`;
                
                case 'moveY':
                    return `// Configurar movimiento continuo en Y
object.userData.moveY = true;
object.userData.moveSpeedY = ${parseFloat(params[0]) / 100};
console.log('‚úÖ Movimiento Y activado');`;
                
                case 'moveZ':
                    return `// Configurar movimiento continuo en Z
object.userData.moveZ = true;
object.userData.moveSpeedZ = ${parseFloat(params[0]) / 100};
console.log('‚úÖ Movimiento Z activado');`;
                
                case 'rotate':
                    return `// Configurar rotaci√≥n continua
object.userData.autoRotate = true;
object.userData.rotateSpeed = ${parseFloat(params[0]) * Math.PI / 180};
object.userData.turns = 0;
console.log('üîÑ Auto-rotaci√≥n activada');`;
                
                case 'goto':
                    return `// Mover a posici√≥n espec√≠fica
object.position.set(${params[0]}, ${params[1]}, ${params[2]});
console.log('üìç Movido a posici√≥n:', object.position);`;
                
                case 'color':
                    const colorMap = {
                        'rojo': '#ef4444',
                        'azul': '#3b82f6',
                        'verde': '#10b981',
                        'amarillo': '#fbbf24'
                    };
                    return `// Cambiar color
if (object.material) {
    object.material.color.setStyle('${colorMap[params[0]] || '#ffffff'}');
    console.log('üé® Color cambiado a ${params[0]}');
}`;
                
                case 'size':
                    const scale = parseInt(params[0]) / 100;
                    return `// Cambiar tama√±o
object.scale.set(${scale}, ${scale}, ${scale});
object.userData.baseScale = ${scale};
console.log('üìè Escala cambiada a ${params[0]}%');`;
                
                case 'show':
                    return `// Mostrar objeto
object.visible = true;
console.log('üëÅÔ∏è Objeto visible');`;
                
                case 'hide':
                    return `// Ocultar objeto
object.visible = false;
console.log('üôà Objeto oculto');`;
                
                case 'fragment':
                    return `// üí• Fragmentar en piezas
fragmentObject(object, ${params[0] || 20});
console.log('üí• Objeto fragmentado en ${params[0] || 20} piezas');`;
                
                case 'fall':
                    return `// üåä Hacer caer con gravedad
makeObjectFall(object);
console.log('üåä Objeto cayendo');`;
                
                case 'fallshatter':
                    return `// üí• Caer y fragmentar
fallAndShatter(object, ${params[0] || 25});
console.log('üí• Objeto cayendo y fragment√°ndose en ${params[0] || 25} piezas');`;
                
                case 'explode':
                    return `// üí• Explosi√≥n
explodeObject(object);
console.log('üí• Objeto explotando');`;
                
                case 'oscillateBlock':
                    return `// üåä Oscilar
object.userData.oscillate = true;
object.userData.oscillateAxis = '${params[0] || 'y'}';
object.userData.oscillateAmplitude = ${params[1] || 1};
object.userData.oscillateFrequency = 1;
object.userData.oscillateCenter = object.position.${params[0] || 'y'};
console.log('üåä Oscilaci√≥n activada en eje ${params[0] || 'y'}');`;
                
                case 'pulseBlock':
                    return `// üíì Pulsar (cambiar tama√±o)
object.userData.pulse = true;
object.userData.pulseSpeed = ${params[0] || 2};
object.userData.pulseAmount = 0.3;
object.userData.baseScale = object.scale.x;
console.log('üíì Pulso activado a velocidad ${params[0] || 2}');`;
                
                case 'wait':
                    return `// ‚ö†Ô∏è NOTA: wait() no funciona aqu√≠
// Usa un temporizador por frames:
object.userData.timerEnabled = true;
object.userData.timerInterval = ${parseFloat(params[0]) * 60}; // frames
console.log('‚è±Ô∏è Temporizador configurado: ${params[0]}s');`;
                
                case 'start':
                    return `// Evento: Al iniciar
console.log('‚ñ∂Ô∏è Programa iniciado');`;
                
                case 'click':
                    return `// Evento: Al hacer clic
// Activar animaci√≥n de bacterias (para celdas MFC)
if (object.type === 'Group') {
    object.userData.animateBacteria = true;
    console.log('ü¶† Bacterias activadas');
} else {
    object.userData.autoRotate = true;
    object.userData.rotateSpeed = 0.05;
    console.log('üîÑ Rotaci√≥n activada por clic');
}`;
                
                case 'repeat':
                    return `// ‚ö†Ô∏è NOTA: Los bucles no funcionan aqu√≠
// En su lugar, configura estados:
object.userData.repeatCount = ${params[0]};
object.userData.currentRepeat = 0;
console.log('üîÅ Repeticiones configuradas: ${params[0]}');`;
                
                case 'forever':
                    return `// Activar animaci√≥n continua
object.userData.autoRotate = true;
object.userData.rotateSpeed = 0.02;
console.log('‚ôæÔ∏è Animaci√≥n continua activada');`;
                
                default:
                    return `// C√≥digo personalizado
// Variables disponibles: object, objects, scene, camera
// Funciones: fragmentObject(), makeObjectFall(), explodeObject(), fallAndShatter()
// 
// üéØ EJEMPLOS DE CONFIGURACI√ìN:
//
// üîÑ Rotar continuamente:
// object.userData.autoRotate = true;
// object.userData.rotateSpeed = 0.05;
//
// ü¶† Animar bacterias (MFC):
// object.userData.animateBacteria = true;
//
// üìç Mover:
// object.userData.moveX = true;
// object.userData.moveSpeedX = 0.02;
//
// üåä Oscilar:
// object.userData.oscillate = true;
// object.userData.oscillateAxis = 'y';
// object.userData.oscillateAmplitude = 1;
// object.userData.oscillateCenter = object.position.y;
//
// üíì Pulsar (escala):
// object.userData.pulse = true;
// object.userData.pulseSpeed = 2;
// object.userData.baseScale = 1;
//
// üåà Color c√≠clico:
// object.userData.colorCycle = true;
// object.userData.colorCycleSpeed = 1;
//
// üí• F√çSICA Y FRAGMENTACI√ìN:
//
// Caer:
// makeObjectFall(object);
//
// Fragmentar en piezas:
// fragmentObject(object, 15); // 15 fragmentos
//
// Caer Y fragmentar:
// fallAndShatter(object, 20); // 20 fragmentos
//
// Explotar:
// explodeObject(object);

console.log('‚öôÔ∏è Configuraci√≥n aplicada');`;
            }
        }
        
        function toggleCodeEditor(index) {
            const editor = document.getElementById(`editor-${index}`);
            if (editor) {
                editor.classList.toggle('active');
            }
        }
        
        function saveBlockCode(index) {
            const textarea = document.getElementById(`code-${index}`);
            if (textarea && programBlocks[index]) {
                programBlocks[index].customCode = textarea.value;
                updateWorkspace();
                updateCodePreview();
            }
        }
        
        function cancelEditCode(index) {
            const editor = document.getElementById(`editor-${index}`);
            if (editor) {
                editor.classList.remove('active');
            }
        }
        
        function removeBlock(index) {
            programBlocks.splice(index, 1);
            updateWorkspace();
            updateCodePreview();
        }
        
        function updateCodePreview() {
            let code = '// C√≥digo JavaScript generado\n\n';
            
            if (programBlocks.length === 0) {
                code = '// El c√≥digo aparecer√° aqu√≠...';
            } else {
                programBlocks.forEach(block => {
                    if (block.customCode && block.customCode.trim()) {
                        code += '// Bloque: ' + block.text + '\n';
                        code += block.customCode + '\n\n';
                    } else {
                        code += '// Bloque: ' + block.text + '\n';
                        code += getDefaultCode(block.type, block.params) + '\n\n';
                    }
                });
            }
            
            document.getElementById('code-preview').textContent = code;
        }
        
        function runSimulation() {
            if (objects.length === 0) {
                alert('Agrega objetos 3D primero');
                return;
            }
            
            if (programBlocks.length === 0) {
                alert('Agrega bloques de programaci√≥n');
                return;
            }
            
            document.getElementById('runModal').classList.add('active');
            document.getElementById('runStatus').innerHTML = `
                <div style="margin-bottom: 10px;">Ejecutando configuraci√≥n...</div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7);">
                    Los bloques configuran animaciones continuas.<br>
                    Las animaciones corren autom√°ticamente en el motor.
                </div>
            `;
            
            isSimulationRunning = true;
            executeBlocks();
            
            setTimeout(() => {
                document.getElementById('runStatus').innerHTML = `
                    <div style="color: #10b981; margin-bottom: 10px;">‚úÖ Configuraci√≥n aplicada</div>
                    <div style="font-size: 12px; line-height: 1.6;">
                        Las animaciones est√°n corriendo continuamente.<br>
                        Puedes cerrar este modal y seguir interactuando.
                    </div>
                `;
            }, 1000);
        }
        
        function executeBlocks() {
            const object = selectedObject || objects[0];
            
            if (!object) {
                console.warn('‚ö†Ô∏è No hay objeto seleccionado para ejecutar');
                return;
            }
            
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('‚ñ∂Ô∏è EJECUTANDO BLOQUES');
            console.log(`üéØ Objeto: ${object.userData.name || 'Sin nombre'}`);
            console.log(`üì¶ Total bloques: ${programBlocks.length}`);
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            programBlocks.forEach((block, index) => {
                try {
                    console.log(`\nüß© Bloque ${index + 1}: ${block.text}`);
                    
                    if (block.customCode && block.customCode.trim()) {
                        // Ejecutar c√≥digo personalizado con funciones de f√≠sica disponibles
                        const customFunction = new Function(
                            'object', 
                            'objects', 
                            'scene', 
                            'camera',
                            'fragmentObject',
                            'makeObjectFall',
                            'explodeObject',
                            'fallAndShatter',
                            'clearFragments',
                            'resetObject',
                            'gridHelper',
                            block.customCode
                        );
                        customFunction(object, objects, scene, camera, fragmentObject, makeObjectFall, explodeObject, fallAndShatter, clearFragments, resetObject, gridHelper);
                        console.log('  ‚úÖ C√≥digo personalizado ejecutado');
                    } else {
                        // Ejecutar c√≥digo por defecto del bloque
                        const defaultCode = getDefaultCode(block.type, block.params);
                        const defaultFunction = new Function(
                            'object', 
                            'objects', 
                            'scene', 
                            'camera',
                            'fragmentObject',
                            'makeObjectFall',
                            'explodeObject',
                            'fallAndShatter',
                            'clearFragments',
                            'resetObject',
                            'gridHelper',
                            defaultCode
                        );
                        defaultFunction(object, objects, scene, camera, fragmentObject, makeObjectFall, explodeObject, fallAndShatter, clearFragments, resetObject, gridHelper);
                        console.log('  ‚úÖ Configuraci√≥n por defecto aplicada');
                    }
                } catch (error) {
                    console.error(`  ‚ùå Error en bloque "${block.text}":`, error.message);
                    alert(`Error en bloque "${block.text}":\n${error.message}\n\nRevisa la consola (F12) para m√°s detalles.`);
                }
            });
            
            console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('‚úÖ TODOS LOS BLOQUES EJECUTADOS');
            console.log('üé¨ Las animaciones corren autom√°ticamente');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
            
            // Mostrar estado del objeto
            console.log('üìä ESTADO DEL OBJETO:', object.userData);
        }
        
        function stopSimulation() {
            isSimulationRunning = false;
            
            // Detener todas las animaciones
            objects.forEach(obj => {
                obj.userData.animate = false;
                obj.userData.autoRotate = false;
                obj.userData.moveX = false;
                obj.userData.moveY = false;
                obj.userData.moveZ = false;
                obj.userData.animateBacteria = false;
                obj.userData.oscillate = false;
                obj.userData.pulse = false;
                obj.userData.colorCycle = false;
            });
            
            console.log('‚èπÔ∏è Todas las animaciones detenidas');
            closeModal();
        }
        
        function closeModal() {
            document.getElementById('runModal').classList.remove('active');
        }
        
        function saveProject() {
            if (objects.length === 0) {
                alert('‚ö†Ô∏è No hay objetos para guardar. Crea algunos objetos 3D primero.');
                return;
            }
            
            document.getElementById('saveObjectCount').textContent = objects.length;
            document.getElementById('saveBlockCount').textContent = programBlocks.length;
            
            document.getElementById('saveModal').classList.add('active');
            
            const now = new Date();
            const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
            document.getElementById('projectName').value = `Proyecto_3D_${dateStr}`;
        }
        
        function confirmSaveProject() {
            const projectName = document.getElementById('projectName').value || 'Proyecto_3D';
            
            const project = {
                version: '2.0',
                type: '3D_Project',
                name: projectName,
                createdAt: new Date().toISOString(),
                objects: objects.map(obj => ({
                    type: obj.userData.type,
                    name: obj.userData.name,
                    id: obj.userData.id,
                    position: {
                        x: obj.position.x,
                        y: obj.position.y,
                        z: obj.position.z
                    },
                    rotation: {
                        x: obj.rotation.x,
                        y: obj.rotation.y,
                        z: obj.rotation.z
                    },
                    scale: {
                        x: obj.scale.x,
                        y: obj.scale.y,
                        z: obj.scale.z
                    },
                    color: '#' + obj.material.color.getHexString(),
                    visible: obj.visible,
                    animate: obj.userData.animate
                })),
                blocks: programBlocks,
                code: document.getElementById('code-preview').textContent,
                cameraPosition: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                }
            };
            
            const dataStr = JSON.stringify(project, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeSaveModal();
            showNotification('‚úÖ Proyecto guardado correctamente en tu carpeta de Descargas', 'success');
        }
        
        function closeSaveModal() {
            document.getElementById('saveModal').classList.remove('active');
        }
        
        function importProject() {
            document.getElementById('importModal').classList.add('active');
            document.getElementById('importStatus').textContent = '';
            document.getElementById('fileInput').value = '';
        }
        
        function loadSelectedFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                document.getElementById('importStatus').innerHTML = '‚ö†Ô∏è Por favor selecciona un archivo';
                document.getElementById('importStatus').style.color = '#f59e0b';
                return;
            }
            
            if (!file.name.endsWith('.json')) {
                document.getElementById('importStatus').innerHTML = '‚ùå El archivo debe ser .json';
                document.getElementById('importStatus').style.color = '#ef4444';
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);
                    
                    if (!project.objects || !Array.isArray(project.objects)) {
                        throw new Error('Formato de proyecto inv√°lido');
                    }
                    
                    const projectType = project.type || 'Unknown';
                    const isMFCProject = projectType === 'MFC_Project';
                    
                    // Limpiar escena actual
                    objects.forEach(obj => scene.remove(obj));
                    objects = [];
                    programBlocks = [];
                    deselectObject();
                    
                    console.log(`üìÇ Cargando proyecto: ${project.name || 'Sin nombre'}`);
                    console.log(`üì¶ Tipo: ${projectType}`);
                    console.log(`üî¢ Objetos a cargar: ${project.objects.length}`);
                    
                    // Cargar objetos
                    project.objects.forEach((objData, index) => {
                        console.log(`  ‚öôÔ∏è Cargando objeto ${index + 1}/${project.objects.length}: ${objData.name || objData.type}`);
                        loadObject(objData, isMFCProject);
                    });
                    
                    console.log(`‚úÖ Total de objetos cargados: ${objects.length}`);
                    console.log('üìã Lista de objetos:', objects.map(o => o.userData.name || o.userData.type));
                    
                    // Cargar bloques
                    if (project.blocks && Array.isArray(project.blocks)) {
                        programBlocks = project.blocks;
                        blockCounter = Math.max(...programBlocks.map(b => b.id), 0) + 1;
                        console.log(`üß© Bloques cargados: ${programBlocks.length}`);
                    }
                    
                    // Restaurar c√°mara
                    if (project.cameraPosition) {
                        camera.position.set(
                            project.cameraPosition.x,
                            project.cameraPosition.y,
                            project.cameraPosition.z
                        );
                        camera.lookAt(0, 0, 0);
                    }
                    
                    updateObjectCount();
                    updateWorkspace();
                    updateCodePreview();
                    
                    closeImportModal();
                    
                    const typeMsg = isMFCProject ? '(Proyecto MFC convertido)' : '(Proyecto 3D est√°ndar)';
                    showNotification(`‚úÖ Proyecto "${project.name || 'Sin nombre'}" cargado ${typeMsg}`, 'success');
                    
                    // Mostrar resumen en consola
                    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('‚úÖ PROYECTO CARGADO EXITOSAMENTE');
                    console.log(`üì¶ Objetos: ${objects.length}`);
                    console.log(`üß© Bloques: ${programBlocks.length}`);
                    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    
                } catch (error) {
                    console.error('‚ùå Error al cargar proyecto:', error);
                    document.getElementById('importStatus').innerHTML = '‚ùå Error: ' + error.message;
                    document.getElementById('importStatus').style.color = '#ef4444';
                }
            };
            
            reader.onerror = function() {
                document.getElementById('importStatus').innerHTML = '‚ùå Error al leer el archivo';
                document.getElementById('importStatus').style.color = '#ef4444';
            };
            
            reader.readAsText(file);
        }
        
        function createMFCChamber(type, color, position) {
            const group = new THREE.Group();
            
            // C√°mara transparente
            const chamberGeometry = new THREE.BoxGeometry(3, 4, 3);
            const chamberMaterial = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const chamber = new THREE.Mesh(chamberGeometry, chamberMaterial);
            group.add(chamber);
            
            // Electrodo
            const electrodeGeometry = new THREE.CylinderGeometry(0.3, 0.3, 3.5, 16);
            const electrodeMaterial = new THREE.MeshPhongMaterial({ 
                color: type === 'anode' ? 0x2c2c2c : 0x757575,
                emissive: 0x111111
            });
            const electrode = new THREE.Mesh(electrodeGeometry, electrodeMaterial);
            group.add(electrode);
            
            // Part√≠culas decorativas si es √°nodo
            if (type === 'anode') {
                for (let i = 0; i < 10; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                    const particleMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff1744,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 2
                    );
                    group.add(particle);
                }
            }
            
            group.position.copy(position);
            return group;
        }
        
        function loadObject(objData, isMFCProject) {
            let mesh;
            
            if (isMFCProject && objData.isMFC) {
                // Recrear celda MFC completa
                const mfcGroup = new THREE.Group();
                
                // √Ånodo (amarillo, izquierda)
                const anode = createMFCChamber('anode', 0xfbbf24, new THREE.Vector3(-2.5, 0, 0));
                mfcGroup.add(anode);
                
                // Membrana (verde, centro)
                const membraneGeometry = new THREE.BoxGeometry(0.15, 4, 3);
                const membraneMaterial = new THREE.MeshPhongMaterial({
                    color: 0x10b981,
                    transparent: true,
                    opacity: 0.6
                });
                const membrane = new THREE.Mesh(membraneGeometry, membraneMaterial);
                membrane.position.set(0, 0, 0);
                mfcGroup.add(membrane);
                
                // C√°todo (azul, derecha)
                const cathode = createMFCChamber('cathode', 0x60a5fa, new THREE.Vector3(2.5, 0, 0));
                mfcGroup.add(cathode);
                
                // Aplicar transformaciones al grupo completo
                mfcGroup.position.set(objData.position.x, objData.position.y, objData.position.z);
                mfcGroup.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                mfcGroup.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                
                mfcGroup.userData = {
                    id: objData.id || Date.now(),
                    type: 'mfc',
                    name: objData.name || 'Celda_MFC_' + (objects.length + 1),
                    animate: objData.userData ? objData.userData.animate : false
                };
                
                scene.add(mfcGroup);
                objects.push(mfcGroup);
                return;
            }
            
            if (isMFCProject) {
                // Componentes individuales MFC
                let geometry, material;
                
                switch(objData.type) {
                    case 'anode':
                        mesh = createMFCChamber('anode', 0xfbbf24, new THREE.Vector3(0, 0, 0));
                        break;
                    case 'cathode':
                        mesh = createMFCChamber('cathode', 0x60a5fa, new THREE.Vector3(0, 0, 0));
                        break;
                    case 'membrane':
                        geometry = new THREE.BoxGeometry(0.15, 4, 3);
                        material = new THREE.MeshPhongMaterial({
                            color: 0x10b981,
                            transparent: true,
                            opacity: 0.6
                        });
                        mesh = new THREE.Mesh(geometry, material);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        material = new THREE.MeshPhongMaterial({ 
                            color: objData.color || '#ef4444'
                        });
                        mesh = new THREE.Mesh(geometry, material);
                }
            } else {
                // Objetos 3D est√°ndar
                let geometry;
                
                switch(objData.type) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(0.5, 32, 32);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(0.5, 1, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                        break;
                    case 'plane':
                        geometry = new THREE.PlaneGeometry(2, 2);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: objData.color || '#ef4444',
                    flatShading: false
                });
                mesh = new THREE.Mesh(geometry, material);
            }
            
            // Aplicar propiedades
            mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
            mesh.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
            mesh.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
            mesh.visible = objData.visible !== undefined ? objData.visible : true;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = {
                id: objData.id || Date.now(),
                type: objData.type,
                name: objData.name || `${objData.type}_${objects.length + 1}`,
                animate: objData.animate || false
            };
            
            scene.add(mesh);
            objects.push(mesh);
        }
        
        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${type === 'success' ? 'linear-gradient(135deg, #10b981, #059669)' : 
                             type === 'error' ? 'linear-gradient(135deg, #ef4444, #dc2626)' : 
                             'linear-gradient(135deg, #3b82f6, #2563eb)'};
                color: white;
                padding: 15px 25px;
                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                z-index: 3000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from {
                        transform: translateX(400px);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOut {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(400px);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
    </script>
</body>
</html>
