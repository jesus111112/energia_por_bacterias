<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celda Microbiana 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 14px;
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        .voltage-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            font-weight: bold;
            border: 3px solid #ff9800;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info">
        <h2>‚ö° Celda Microbiana MFC</h2>
        <p><strong>Componentes:</strong></p>
        <p>üîµ C√°mara An√≥dica (tierra/agua)<br>
        üü† C√°mara Cat√≥dica (zinc/agua)<br>
        üåâ Puente salino (membrana)<br>
        ‚ö° Electrodos conectados<br>
        üìü Mult√≠metro (arrastrable)</p>
        <p style="font-size: 12px; margin-top: 10px;">
        <em>Arrastra el mult√≠metro con clic<br>
        Mouse para rotar escena<br>
        Scroll para zoom</em>
        </p>
    </div>

    <div class="voltage-display">0.478 V</div>

    <div id="controls">
        <button onclick="resetView()">Restablecer Vista</button>
        <button onclick="toggleAnimation()">Pausar/Reanudar</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let animationId;
        let isAnimating = true;
        let multimeter, redCable, blackCable;
        let isDraggingMultimeter = false;
        let isDraggingScene = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let multimeterPosition = new THREE.Vector3(0, 3, 3);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2332);
            scene.fog = new THREE.Fog(0x1a2332, 10, 50);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 4, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const fillLight = new THREE.PointLight(0x4488ff, 0.5);
            fillLight.position.set(-5, 3, -5);
            scene.add(fillLight);

            createMicrobialCell();

            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -2;
            plane.receiveShadow = true;
            scene.add(plane);

            setupControls();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createMicrobialCell() {
            const cellGroup = new THREE.Group();

            // C√°mara An√≥dica (transl√∫cida)
            const anodicChamber = createChamber(0xdddddd, 0.4, -2, 0);
            cellGroup.add(anodicChamber);

            // L√≠quido en c√°mara an√≥dica (tierra/agua - m√°s oscuro)
            const anodicLiquid = createLiquid(0x8b7355, -2);
            cellGroup.add(anodicLiquid);

            // C√°mara Cat√≥dica (marr√≥n oscuro)
            const cathodicChamber = createChamber(0x4a3020, 0.8, 2, 0);
            cellGroup.add(cathodicChamber);

            // Tapa naranja
            const lidGeometry = new THREE.CylinderGeometry(1.1, 1.1, 0.15, 32);
            const lidMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff5722,
                roughness: 0.4,
                metalness: 0.2
            });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.set(2, 1.5, 0);
            lid.castShadow = true;
            cellGroup.add(lid);

            // L√≠quido en c√°mara cat√≥dica (zinc/agua - gris√°ceo)
            const cathodicLiquid = createLiquid(0xa0a0a0, 2);
            cellGroup.add(cathodicLiquid);

            // PUENTE SALINO M√ÅS CORTO - solo toca los l√≠quidos
            const bridgeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3.2, 16);
            const bridgeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4a574,
                roughness: 0.7
            });
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.rotation.z = Math.PI / 2;
            bridge.position.set(0, 0, 0);
            bridge.castShadow = true;
            cellGroup.add(bridge);

            // Electrodo √ÅNODO (izquierda) - posici√≥n guardada para cables
            const anodeGeometry = new THREE.BoxGeometry(0.3, 1.5, 0.05);
            const anodeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.9,
                roughness: 0.2
            });
            const anode = new THREE.Mesh(anodeGeometry, anodeMaterial);
            anode.position.set(-2, -0.3, 0);
            anode.castShadow = true;
            cellGroup.add(anode);
            cellGroup.userData.anodePos = new THREE.Vector3(-2, 0.5, 0);

            // Electrodo C√ÅTODO (derecha) - posici√≥n guardada para cables
            const cathode = new THREE.Mesh(anodeGeometry, anodeMaterial);
            cathode.position.set(2, -0.3, 0);
            cathode.castShadow = true;
            cellGroup.add(cathode);
            cellGroup.userData.cathodePos = new THREE.Vector3(2, 0.5, 0);

            // Part√≠culas de energ√≠a
            createEnergyParticles(cellGroup);

            scene.add(cellGroup);

            // Crear mult√≠metro DESPU√âS de la celda
            createMultimeter();
            
            // Crear cables que conectan electrodos al mult√≠metro
            createDynamicCables(cellGroup.userData.anodePos, cellGroup.userData.cathodePos);
        }

        function createChamber(color, opacity, xPos, yPos) {
            const geometry = new THREE.CylinderGeometry(1, 1, 2.5, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                transparent: true,
                opacity: opacity,
                roughness: 0.3,
                metalness: 0.1
            });
            const chamber = new THREE.Mesh(geometry, material);
            chamber.position.set(xPos, yPos, 0);
            chamber.castShadow = true;
            chamber.receiveShadow = true;
            return chamber;
        }

        function createLiquid(color, xPos) {
            const geometry = new THREE.CylinderGeometry(0.95, 0.95, 2, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1,
                metalness: 0.3
            });
            const liquid = new THREE.Mesh(geometry, material);
            liquid.position.set(xPos, -0.2, 0);
            return liquid;
        }

        function createMultimeter() {
            const multimeterGroup = new THREE.Group();

            // Cuerpo del mult√≠metro
            const bodyGeometry = new THREE.BoxGeometry(1.2, 1.8, 0.3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.5,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            multimeterGroup.add(body);

            // Borde naranja
            const borderGeometry = new THREE.BoxGeometry(1.25, 1.85, 0.28);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff9800,
                roughness: 0.6
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.z = -0.01;
            multimeterGroup.add(border);

            // Pantalla LCD
            const screenGeometry = new THREE.BoxGeometry(0.9, 0.5, 0.05);
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xc8d6b9,
                emissive: 0x4a5a3a,
                emissiveIntensity: 0.3
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 0.5, 0.16);
            multimeterGroup.add(screen);

            // Selector central
            const selectorGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
            const selectorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.7
            });
            const selector = new THREE.Mesh(selectorGeometry, selectorMaterial);
            selector.rotation.x = Math.PI / 2;
            selector.position.set(0, -0.3, 0.2);
            multimeterGroup.add(selector);

            // Botones
            for (let i = 0; i < 3; i++) {
                const buttonGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.05);
                const buttonMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x666666,
                    roughness: 0.5
                });
                const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
                button.position.set(-0.3 + i * 0.3, 0.15, 0.18);
                multimeterGroup.add(button);
            }

            // Conectores (donde se insertan los cables)
            const connectorGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.15, 8);
            
            // Conector NEGRO (COM)
            const blackConnectorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                metalness: 0.7,
                roughness: 0.3
            });
            const blackConnector = new THREE.Mesh(connectorGeometry, blackConnectorMaterial);
            blackConnector.position.set(-0.3, -0.8, 0.15);
            blackConnector.rotation.x = Math.PI / 2;
            multimeterGroup.add(blackConnector);
            multimeterGroup.userData.blackPort = new THREE.Vector3(-0.3, -0.8, 0.15);

            // Conector ROJO (V)
            const redConnectorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                metalness: 0.7,
                roughness: 0.3
            });
            const redConnector = new THREE.Mesh(connectorGeometry, redConnectorMaterial);
            redConnector.position.set(0.3, -0.8, 0.15);
            redConnector.rotation.x = Math.PI / 2;
            multimeterGroup.add(redConnector);
            multimeterGroup.userData.redPort = new THREE.Vector3(0.3, -0.8, 0.15);

            multimeterGroup.position.copy(multimeterPosition);
            multimeterGroup.userData.draggable = true;
            multimeter = multimeterGroup;
            scene.add(multimeterGroup);
        }

        function createDynamicCables(anodePos, cathodePos) {
            // Cable NEGRO: del √°nodo al puerto negro del mult√≠metro
            const blackCableGeometry = new THREE.BufferGeometry();
            blackCable = new THREE.Line(
                blackCableGeometry,
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            scene.add(blackCable);

            // Cable ROJO: del c√°todo al puerto rojo del mult√≠metro
            const redCableGeometry = new THREE.BufferGeometry();
            redCable = new THREE.Line(
                redCableGeometry,
                new THREE.LineBasicMaterial({ color: 0xff0066, linewidth: 2 })
            );
            scene.add(redCable);

            updateCables(anodePos, cathodePos);
        }

        function updateCables(anodePos, cathodePos) {
            if (!multimeter || !blackCable || !redCable) return;

            const multimeterWorldPos = new THREE.Vector3();
            multimeter.getWorldPosition(multimeterWorldPos);

            // Posiciones de los puertos del mult√≠metro en coordenadas mundiales
            const blackPortWorld = multimeter.userData.blackPort.clone();
            blackPortWorld.applyMatrix4(multimeter.matrixWorld);

            const redPortWorld = multimeter.userData.redPort.clone();
            redPortWorld.applyMatrix4(multimeter.matrixWorld);

            // Cable NEGRO: √°nodo -> puerto negro
            const blackCurve = new THREE.QuadraticBezierCurve3(
                anodePos,
                new THREE.Vector3(
                    (anodePos.x + blackPortWorld.x) / 2,
                    Math.max(anodePos.y, blackPortWorld.y) + 1,
                    (anodePos.z + blackPortWorld.z) / 2
                ),
                blackPortWorld
            );
            const blackPoints = blackCurve.getPoints(50);
            blackCable.geometry.setFromPoints(blackPoints);

            // Cable ROJO: c√°todo -> puerto rojo
            const redCurve = new THREE.QuadraticBezierCurve3(
                cathodePos,
                new THREE.Vector3(
                    (cathodePos.x + redPortWorld.x) / 2,
                    Math.max(cathodePos.y, redPortWorld.y) + 1,
                    (cathodePos.z + redPortWorld.z) / 2
                ),
                redPortWorld
            );
            const redPoints = redCurve.getPoints(50);
            redCable.geometry.setFromPoints(redPoints);
        }

        function createEnergyParticles(group) {
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 6;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({ 
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            group.add(particles);
        }

        function setupControls() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('mousedown', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj.parent && !obj.userData.draggable) {
                        obj = obj.parent;
                    }
                    if (obj.userData.draggable) {
                        isDraggingMultimeter = true;
                        return;
                    }
                }

                isDraggingScene = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDraggingMultimeter && multimeter) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                    const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                    vector.unproject(camera);
                    const dir = vector.sub(camera.position).normalize();
                    const distance = (multimeter.position.z - camera.position.z) / dir.z;
                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                    
                    multimeter.position.x = pos.x;
                    multimeter.position.y = pos.y;

                    // Actualizar cables din√°micamente
                    const anodePos = new THREE.Vector3(-2, 0.5, 0);
                    const cathodePos = new THREE.Vector3(2, 0.5, 0);
                    updateCables(anodePos, cathodePos);

                } else if (isDraggingScene) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    rotation.y += deltaX * 0.005;
                    rotation.x += deltaY * 0.005;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDraggingMultimeter = false;
                isDraggingScene = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(3, Math.min(15, camera.position.z));
            });
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (isAnimating) {
                scene.rotation.y = rotation.y;
                scene.rotation.x = rotation.x;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetView() {
            camera.position.set(5, 4, 8);
            camera.lookAt(0, 0, 0);
            rotation = { x: 0, y: 0 };
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
        }

        init();
    </script>
</body>
</html>
